---
title: duck query
description: Type-safe Axios client for Duck Gen routes.
---

## What is Duck Query?

Duck Query is a small, typed HTTP client built on Axios. It uses route metadata to give you fully typed request and
response shapes, and it works especially well with the types generated by Duck Gen.

## Install

<Steps>

<Step>Install the client</Step>

```bash
pnpm add @gentleduck/query
```

<Step>Optional: install Duck Gen types</Step>

```bash
pnpm add -D @gentleduck/gen
```

</Steps>

## Quick start

```ts
import { createDuckQueryClient } from '@gentleduck/query'
import type { ApiRoutes } from '@gentleduck/gen/nestjs'

const client = createDuckQueryClient<ApiRoutes>({
  baseURL: 'http://localhost:3000',
  withCredentials: true,
})

const { data } = await client.post('/api/auth/signin', {
  body: {
    username: 'duck',
    password: '123456',
  },
})
```

If you configured Duck Gen to write to custom output paths, import `ApiRoutes`
and any helper types from those files instead of `@gentleduck/gen/nestjs`.

## Request shape

Every route request is a small object with up to four fields:

- `body`: JSON body for POST, PUT, PATCH.
- `query`: Query string values.
- `params`: Path params for routes like `/users/:id`.
- `headers`: Per-request headers.

```ts
await client.get('/api/users/:id', {
  params: { id: 'u_123' },
  query: { with: 'profile' },
  headers: { authorization: 'Bearer token' },
})
```

Notes:

- `params` replaces `:id` placeholders in the URL.
- `query` overrides `config.params` if both are provided.
- `headers` overrides `config.headers` if both are provided.

## Client methods

Duck Query returns a typed client with these methods:

- `get(path, req?, config?)`
- `post(path, req, config?)`
- `put(path, req, config?)`
- `patch(path, req, config?)`
- `del(path, req?, config?)`
- `request(path, req?, config?)` (method from `config.method`, default GET)
- `byMethod(method, path, req?, config?)` (explicit method string)
- `axios` (the underlying Axios instance)

```ts
client.axios.interceptors.request.use((config) => {
  config.headers = {
    ...config.headers,
    'x-app': 'duck-ui',
  }
  return config
})
```

## React Query (TanStack Query)

```bash
pnpm add @tanstack/react-query
```

Wrap your app with a query client provider before using hooks:

```tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import * as React from 'react'

const queryClient = new QueryClient()

export function Providers({ children }: { children: React.ReactNode }) {
  return <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
}
```

```tsx
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query'
import { createDuckQueryClient } from '@gentleduck/query'
import type { ApiRoutes, RouteReq, RouteRes } from '@gentleduck/gen/nestjs'

const client = createDuckQueryClient<ApiRoutes>({ baseURL: 'http://localhost:3000' })

type SigninReq = RouteReq<'/api/auth/signin'>
type SigninRes = RouteRes<'/api/auth/signin'>

export function useSignin() {
  const qc = useQueryClient()
  return useMutation<SigninRes, unknown, SigninReq>({
    mutationFn: async (req) => {
      const { data } = await client.post('/api/auth/signin', req)
      return data
    },
    onSuccess: () => qc.invalidateQueries({ queryKey: ['auth'] }),
  })
}

type UserRes = RouteRes<'/api/users/:id'>

export function useUser(id: string) {
  return useQuery({
    queryKey: ['users', id],
    enabled: Boolean(id),
    queryFn: async () => {
      const { data } = await client.get('/api/users/:id', { params: { id } })
      return data
    },
  })
}
```

Replace `/api/users/:id` with a GET route from your `ApiRoutes`.

## Types

Duck Query exposes helper types so you can build or inspect route maps manually.

```ts
import type {
  DuckRouteMeta,
  DuckApiRoutes,
  RoutePath,
  RouteOf,
  RouteMethod,
  RouteRes,
  RouteReq,
  RouteMethods,
  PathsByMethod,
} from '@gentleduck/query'

type Routes = {
  '/api/users/:id': {
    method: 'GET'
    params: { id: string }
    query: { with?: 'profile' }
    headers: { authorization: string }
    body: never
    res: { id: string; username: string }
  }
}

type Paths = RoutePath<Routes>
// '/api/users/:id'

type UserRes = RouteRes<Routes, '/api/users/:id'>
// { id: string; username: string }
```

## Using without Duck Gen

You can supply your own route map if you are not using Duck Gen.

```ts
import { createDuckQueryClient } from '@gentleduck/query'

type Routes = {
  '/ping': {
    method: 'GET'
    params: never
    query: never
    headers: never
    body: never
    res: { ok: true }
  }
}

const client = createDuckQueryClient<Routes>({ baseURL: 'http://localhost:3000' })
const { data } = await client.get('/ping')
```

## Error handling

Duck Query returns Axios responses, so errors are thrown as Axios errors.

```ts
try {
  const { data } = await client.post('/api/auth/signin', {
    body: { username: 'duck', password: 'bad' },
  })
  return data
} catch (error) {
  console.error('Signin failed', error)
}
```

## Behavior details

- Methods like GET and DELETE ignore `body` even if it exists.
- `request` uses `config.method` and defaults to GET if it is missing.
- Paths are type-checked against the method you call, so you cannot `post` to a GET-only route.
