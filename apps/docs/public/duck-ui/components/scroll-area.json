{
  "name": "scroll-area",
  "type": "registry:ui",
  "dependencies": [
    "@gentleduck/libs"
  ],
  "root_folder": "scroll-area",
  "files": [
    {
      "path": "scroll-area/index.ts",
      "content": "export * from './scroll-area'\n",
      "type": "registry:ui",
      "target": "components/ui/index.ts"
    },
    {
      "path": "scroll-area/scroll-area.tsx",
      "content": "import { cn } from '@gentleduck/libs/cn'\nimport * as React from 'react'\n\ninterface ScrollAreaProps extends React.HTMLAttributes<HTMLDivElement> {\n  alwaysVisible?: boolean\n  viewportClassName?: string\n  orientation?: 'vertical' | 'horizontal' | 'both'\n}\n\nconst ScrollArea = ({\n  children,\n  className,\n  viewportClassName,\n  alwaysVisible = false,\n  orientation = 'vertical',\n  style,\n  ...props\n}: ScrollAreaProps) => {\n  const V_THICKNESS = 4\n  const H_THICKNESS = 4\n  const containerRef = React.useRef<HTMLDivElement>(null)\n  const viewportRef = React.useRef<HTMLDivElement>(null)\n  const vThumbRef = React.useRef<HTMLDivElement>(null)\n  const hThumbRef = React.useRef<HTMLDivElement>(null)\n  const vTrackRef = React.useRef<HTMLDivElement>(null)\n  const hTrackRef = React.useRef<HTMLDivElement>(null)\n\n  const updateThumbs = () => {\n    const viewport = viewportRef.current\n    if (!viewport) return\n    // Vertical\n    if (orientation === 'vertical' || orientation === 'both') {\n      const thumb = vThumbRef.current!\n      const track = vTrackRef.current!\n      const scrollSize = viewport.scrollHeight\n      const clientSize = viewport.clientHeight\n      const scrollOffset = viewport.scrollTop\n      const ratio = clientSize / scrollSize\n      const thumbSize = Math.max(ratio * clientSize, 24)\n      const maxThumbOffset = track.clientHeight - thumbSize\n      const offset = maxThumbOffset === 0 ? 0 : (scrollOffset / (scrollSize - clientSize)) * maxThumbOffset\n      thumb.style.height = `${thumbSize}px`\n      thumb.style.transform = `translateY(${offset}px)`\n      thumb.style.opacity = ratio < 1 || alwaysVisible ? '1' : '0'\n      track.style.opacity = ratio < 1 || alwaysVisible ? '1' : '0'\n    }\n    // Horizontal\n    if (orientation === 'horizontal' || orientation === 'both') {\n      const thumb = hThumbRef.current!\n      const track = hTrackRef.current!\n      const scrollSize = viewport.scrollWidth\n      const clientSize = viewport.clientWidth\n      const scrollOffset = viewport.scrollLeft\n      const ratio = clientSize / scrollSize\n      const thumbSize = Math.max(ratio * clientSize, 24)\n      const maxThumbOffset = track.clientWidth - thumbSize\n      const offset = maxThumbOffset === 0 ? 0 : (scrollOffset / (scrollSize - clientSize)) * maxThumbOffset\n      thumb.style.width = `${thumbSize}px`\n      thumb.style.transform = `translateX(${offset}px)`\n      thumb.style.opacity = ratio < 1 || alwaysVisible ? '1' : '0'\n      track.style.opacity = ratio < 1 || alwaysVisible ? '1' : '0'\n    }\n  }\n\n  const startDrag = (isVertical: boolean, clientPos: number) => {\n    const viewport = viewportRef.current!\n    const thumb = isVertical ? vThumbRef.current! : hThumbRef.current!\n    const track = isVertical ? vTrackRef.current! : hTrackRef.current!\n    const thumbSize = isVertical ? thumb.offsetHeight : thumb.offsetWidth\n    const trackSize = isVertical ? track.offsetHeight : track.offsetWidth\n    const maxThumbOffset = trackSize - thumbSize\n    const scrollRange = isVertical\n      ? viewport.scrollHeight - viewport.clientHeight\n      : viewport.scrollWidth - viewport.clientWidth\n    const initialOffset = parseFloat(thumb.style.transform.match(/-?\\d+\\.?\\d*/)?.[0] || '0')\n\n    const onMouseMove = (e: MouseEvent) => {\n      const delta = (isVertical ? e.clientY : e.clientX) - clientPos\n      const thumbOffset = Math.min(Math.max(initialOffset + delta, 0), maxThumbOffset)\n      const scrollOffset = (thumbOffset / maxThumbOffset) * scrollRange\n      if (isVertical) viewport.scrollTop = scrollOffset\n      else viewport.scrollLeft = scrollOffset\n    }\n    const onMouseUp = () => {\n      document.removeEventListener('mousemove', onMouseMove)\n      document.removeEventListener('mouseup', onMouseUp)\n    }\n    document.addEventListener('mousemove', onMouseMove)\n    document.addEventListener('mouseup', onMouseUp)\n  }\n\n  const onDragThumb = (e: React.MouseEvent<HTMLDivElement>, isVertical: boolean) => {\n    e.preventDefault()\n    startDrag(isVertical, isVertical ? e.clientY : e.clientX)\n  }\n\n  const onClickTrack = (e: React.MouseEvent<HTMLDivElement>, isVertical: boolean) => {\n    const viewport = viewportRef.current!\n    const thumb = isVertical ? vThumbRef.current! : hThumbRef.current!\n    const track = isVertical ? vTrackRef.current! : hTrackRef.current!\n    if (e.target === thumb) return\n    const rect = track.getBoundingClientRect()\n    const clickPos = isVertical ? e.clientY - rect.top : e.clientX - rect.left\n    const thumbSize = isVertical ? thumb.offsetHeight : thumb.offsetWidth\n    const maxThumbOffset = (isVertical ? track.offsetHeight : track.offsetWidth) - thumbSize\n    const newThumbOffset = Math.min(Math.max(clickPos - thumbSize / 2, 0), maxThumbOffset)\n    const scrollRange = isVertical\n      ? viewport.scrollHeight - viewport.clientHeight\n      : viewport.scrollWidth - viewport.clientWidth\n    const scrollOffset = (newThumbOffset / maxThumbOffset) * scrollRange\n    if (isVertical) viewport.scrollTop = scrollOffset\n    else viewport.scrollLeft = scrollOffset\n  }\n\n  React.useEffect(() => {\n    const viewport = viewportRef.current!\n    updateThumbs()\n    viewport.addEventListener('scroll', updateThumbs)\n    const obs = new ResizeObserver(updateThumbs)\n    obs.observe(viewport)\n    return () => {\n      viewport.removeEventListener('scroll', updateThumbs)\n      obs.disconnect()\n    }\n  }, [orientation])\n\n  // Styles\n  const isV = orientation === 'vertical' || orientation === 'both'\n  const isH = orientation === 'horizontal' || orientation === 'both'\n  const vTrackStyle: React.CSSProperties = { width: V_THICKNESS, height: '100%', right: 0, top: 0 }\n  const hTrackStyle: React.CSSProperties = { height: H_THICKNESS, width: '100%', bottom: 0, left: 0 }\n  const paddingStyle: React.CSSProperties = {\n    paddingRight: isV ? V_THICKNESS : 0,\n    paddingBottom: isH ? H_THICKNESS : 0,\n  }\n\n  return (\n    <div ref={containerRef} className={cn('relative overflow-hidden', className)} style={style} {...props}>\n      <div\n        ref={viewportRef}\n        className={cn('scrollbar-none h-full w-full overflow-auto', viewportClassName)}\n        style={paddingStyle}>\n        {children}\n      </div>\n\n      {isV && (\n        <div\n          ref={vTrackRef}\n          onMouseDown={(e) => onClickTrack(e, true)}\n          className=\"absolute bg-transparent opacity-0 hover:opacity-100\"\n          style={vTrackStyle}>\n          <div\n            ref={vThumbRef}\n            onMouseDown={(e) => onDragThumb(e, true)}\n            className=\"absolute right-0 w-full rounded-full bg-secondary hover:bg-secondary\"\n          />\n        </div>\n      )}\n\n      {isH && (\n        <div\n          ref={hTrackRef}\n          onMouseDown={(e) => onClickTrack(e, false)}\n          className=\"absolute bg-transparent opacity-0 hover:opacity-100\"\n          style={hTrackStyle}>\n          <div\n            ref={hThumbRef}\n            onMouseDown={(e) => onDragThumb(e, false)}\n            className=\"absolute bottom-0 h-full rounded-full bg-secondary hover:bg-secondary\"\n          />\n        </div>\n      )}\n    </div>\n  )\n}\n\nexport { ScrollArea }\n",
      "type": "registry:ui",
      "target": "components/ui/scroll-area.tsx"
    }
  ],
  "source": "/registry-ui-duckui/src/scroll-area"
}