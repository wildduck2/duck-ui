{
  "name": "command",
  "type": "registry:ui",
  "dependencies": [
    "@gentleduck/vim",
    "@gentleduck/libs"
  ],
  "registryDependencies": [
    "scroll-area",
    "dialog"
  ],
  "root_folder": "command",
  "files": [
    {
      "path": "command/command.hooks.ts",
      "content": "'use client'\n\nimport React from 'react'\nimport { CommandContext, CommandRefsContext } from './command'\nimport { dstyleItem, handleItemsSelection, styleItem } from './command.libs'\nimport type { CommandContextType, CommandRefsContextType } from './command.types'\n\n/**\n * Custom hook to access the CommandContext.\n *\n * @function useCommandContext\n * @returns {CommandContextType} The command context value.\n * @throws Will throw an error if the hook is used outside of a CommandProvider.\n */\nexport function useCommandContext(): CommandContextType {\n  const context = React.useContext(CommandContext)\n  if (!context) {\n    throw new Error('useCommandContext must be used within a CommandProvider')\n  }\n  return context\n}\n\n/**\n * Custom hook to access the CommandRefsContext.\n *\n * @function useCommandRefsContext\n * @returns {CommandRefsContextType} The command refs context value.\n * @throws Will throw an error if the hook is used outside of a CommandProvider.\n */\nexport function useCommandRefsContext(): CommandRefsContextType {\n  const context = React.useContext(CommandRefsContext)\n  if (!context) {\n    throw new Error('useCommandContext must be used within a CommandProvider')\n  }\n  return context\n}\n\nexport function useCommandElements(commandRef: React.RefObject<HTMLDivElement | null>) {\n  const itemsRef = React.useRef<HTMLLIElement[]>([])\n  const filteredItemsRef = React.useRef<HTMLLIElement[]>([])\n  const groupsRef = React.useRef<HTMLDivElement[]>([])\n  const selectedItemRef = React.useRef<HTMLLIElement | null>(null)\n\n  React.useEffect(() => {\n    if (!commandRef.current) return\n    const _items = commandRef.current.querySelectorAll('li[duck-command-item]')\n    const _groups = commandRef.current.querySelectorAll('div[duck-command-group]')\n    itemsRef.current = Array.from(_items) as HTMLLIElement[]\n    groupsRef.current = Array.from(_groups) as HTMLDivElement[]\n    filteredItemsRef.current = itemsRef.current\n\n    for (let i = 0; i < itemsRef.current.length; i++) {\n      const item = itemsRef.current[i] as HTMLLIElement\n      item.addEventListener('mouseenter', () => {\n        for (let i = 0; i < itemsRef.current?.length; i++) {\n          const item = itemsRef.current[i] as HTMLLIElement\n          dstyleItem(item)\n        }\n\n        styleItem(item)\n        selectedItemRef.current = item\n      })\n    }\n\n    styleItem(itemsRef.current[0] ?? null)\n  }, [])\n\n  return { itemsRef, groupsRef, filteredItemsRef, selectedItemRef }\n}\n\nexport function useCommandSearch(\n  itemsRef: React.RefObject<HTMLLIElement[]>,\n  search: string,\n  setSelectedItem: React.Dispatch<React.SetStateAction<HTMLLIElement | null>>,\n  emptyRef: React.RefObject<HTMLHeadingElement | null>,\n  commandRef: React.RefObject<HTMLDivElement | null>,\n  groups: React.RefObject<HTMLDivElement[]>,\n  filteredItems: React.RefObject<HTMLLIElement[]>,\n): void {\n  React.useEffect(() => {\n    if (!commandRef.current || itemsRef.current.length === 0) return\n    const itemsHidden = new Map<string, HTMLLIElement>()\n\n    // Hiding the items that don't match the search query\n    for (let i = 0; i < itemsRef.current.length; i++) {\n      const item = itemsRef.current[i] as HTMLLIElement\n\n      if (item.textContent?.toLowerCase().includes(search.toLowerCase())) {\n        item.classList.remove('hidden')\n      } else {\n        item.classList.add('hidden')\n        dstyleItem(item)\n        itemsHidden.set(i.toString(), item)\n      }\n    }\n\n    // Toggling the empty message if all items are hidden\n    if (itemsHidden.size === itemsRef.current.length) {\n      emptyRef.current?.classList.remove('hidden')\n      setSelectedItem(null)\n    } else {\n      emptyRef.current?.classList.add('hidden')\n      setSelectedItem(itemsRef.current[0] as HTMLLIElement)\n    }\n\n    // Setting filteredItems to the items that are not hidden\n    filteredItems.current = Array.from(commandRef.current.querySelectorAll('li[duck-command-item]:not(.hidden)'))\n    // Clearing all the classes from the items\n    filteredItems.current.map((item) => dstyleItem(item))\n\n    // Toggling the groups if they have no items\n    for (let i = 0; i < groups.current.length; i++) {\n      const group = groups.current[i] as HTMLDivElement\n      const groupItems = group.querySelectorAll('li[duck-command-item]:not(.hidden)') as NodeListOf<HTMLLIElement>\n      const nextSeparator = group.nextElementSibling\n      const hasSeparator = nextSeparator?.hasAttribute('duck-command-separator')\n\n      if (groupItems.length === 0) {\n        group.classList.add('hidden')\n        // Hiding the separator if the group has no items\n        if (hasSeparator && nextSeparator) nextSeparator.classList.add('hidden')\n      } else {\n        group.classList.remove('hidden')\n        // Showing the separator if the group has items\n        if (hasSeparator && nextSeparator) nextSeparator.classList.remove('hidden')\n      }\n    }\n\n    // Styling the first item after search\n    const item = filteredItems.current?.[0] as HTMLLIElement\n    styleItem(item ?? null)\n    item?.focus()\n    setSelectedItem(item ?? null)\n  }, [search])\n}\n\nexport function useHandleKeyDown({\n  selectedItem,\n  setSelectedItem,\n  open,\n  itemsRef,\n  originalItemsRef,\n  allowAxisArrowKeys = false,\n}: {\n  open?: boolean\n  itemsRef: React.RefObject<HTMLLIElement[]>\n  selectedItem: HTMLLIElement | null\n  setSelectedItem: (item: HTMLLIElement) => void\n  originalItemsRef: React.RefObject<HTMLLIElement[]>\n  allowAxisArrowKeys?: boolean\n}) {\n  React.useEffect(() => {\n    if (!open) return\n\n    const idx = originalItemsRef.current?.findIndex((item) => item === selectedItem)\n    let originalCurrentItem = idx === -1 ? 0 : idx\n    let currentItem = idx === -1 ? 0 : idx\n    let inSubMenu = false\n\n    function handleKeyDown(e: KeyboardEvent) {\n      if (e.key === 'ArrowDown') {\n        e.preventDefault()\n        if (inSubMenu) return\n        const itemIndex = currentItem === itemsRef.current.length - 1 ? 0 : currentItem + 1\n        currentItem = itemIndex\n        originalCurrentItem = itemIndex\n      } else if (e.key === 'ArrowUp') {\n        e.preventDefault()\n        if (inSubMenu) return\n        const itemIndex = currentItem === 0 ? itemsRef.current.length - 1 : currentItem - 1\n        currentItem = itemIndex\n        originalCurrentItem = itemIndex\n      } else if (e.key === 'Enter') {\n        if (\n          itemsRef.current[currentItem]?.hasAttribute('duck-select-item') ||\n          itemsRef.current[currentItem]?.hasAttribute('duck-command-item')\n        ) {\n          e.preventDefault()\n          e.stopPropagation()\n          setSelectedItem(itemsRef.current[currentItem] as HTMLLIElement)\n          itemsRef.current[currentItem]?.click()\n        }\n      }\n\n      if (e.key === 'Enter' || e.key === 'Escape') {\n        if (itemsRef.current[currentItem]?.hasAttribute('duck-dropdown-menu-sub-trigger')) {\n          inSubMenu = !inSubMenu\n        }\n      }\n\n      if (allowAxisArrowKeys) {\n        const item = itemsRef.current[originalCurrentItem] as HTMLLIElement\n        if (item.hasAttribute('duck-dropdown-menu-sub-trigger')) {\n          if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {\n            inSubMenu = !inSubMenu\n            item?.click()\n            return\n          }\n        }\n      }\n\n      handleItemsSelection(currentItem, itemsRef, setSelectedItem)\n    }\n\n    document?.addEventListener('keydown', handleKeyDown)\n    return () => document?.removeEventListener('keydown', handleKeyDown)\n  }, [open])\n}\n",
      "type": "registry:ui",
      "target": "components/ui/command.hooks.ts"
    },
    {
      "path": "command/command.libs.ts",
      "content": "'use client'\n\n/**\n * Function to style the selected item\n * @function styleItem\n * @param {HTMLLIElement} item\n * @returns {void}\n */\nexport function styleItem(item: HTMLLIElement | null): void {\n  if (!item) return\n  // if (item.hasAttribute('duck-select-item') || item.hasAttribute('duck-command-item')) {\n  //   item.scrollIntoView({ block: 'nearest', behavior: 'smooth' })\n  // }\n  item.setAttribute('aria-selected', '')\n  item.focus()\n}\n\n/**\n * Function to unstyle the selected item\n * @function dstyleItem\n * @param {HTMLLIElement} item\n * @returns {void}\n */\nexport function dstyleItem(item: HTMLLIElement | null): void {\n  if (!item) return\n  item.removeAttribute('aria-selected')\n  item.blur()\n}\n\nexport function handleItemsSelection(\n  currentItem: number,\n  itemsRef: React.RefObject<HTMLLIElement[]>,\n  setSelectedItem: (item: HTMLLIElement) => void,\n) {\n  // This will remove the class from all filteredItems.and add it to the right one.\n  for (let i = 0; i < itemsRef.current.length; i++) {\n    const item = itemsRef.current[i] as HTMLLIElement\n    dstyleItem(item)\n\n    if (i === currentItem) {\n      styleItem(item)\n      setSelectedItem(item)\n    }\n  }\n}\n",
      "type": "registry:ui",
      "target": "components/ui/command.libs.ts"
    },
    {
      "path": "command/command.tsx",
      "content": "'use client'\n\nimport { cn } from '@gentleduck/libs/cn'\nimport { Search } from 'lucide-react'\nimport React from 'react'\nimport { Dialog, DialogContent, type DialogProps } from '../dialog'\nimport { ScrollArea } from '../scroll-area'\nimport {\n  useCommandContext,\n  useCommandElements,\n  useCommandRefsContext,\n  useCommandSearch,\n  useHandleKeyDown,\n} from './command.hooks'\nimport type { CommandBadgeProps, CommandContextType, CommandGroupProps, CommandRefsContextType } from './command.types'\n\n/**\n * The CommandContext provides the current search query and a function to update it.\n * @type {React.Context<CommandContextType | null>}\n */\nexport const CommandContext: React.Context<CommandContextType | null> = React.createContext<CommandContextType | null>(\n  null,\n)\n\n/**\n * The CommandRefsContext provides references to various elements within the command palette.\n * @type {React.Context<CommandRefsContextType | null>}\n */\nexport const CommandRefsContext: React.Context<CommandRefsContextType | null> =\n  React.createContext<CommandRefsContextType | null>(null)\n\n/**\n * The CommandRefs component is a wrapper for the Command component.\n * It provides references to various elements within the command palette.\n * @function CommandRefs\n * @returns {React.JSX.Element} The rendered CommandRefs component.\n */\nfunction CommandRefs({ children }: { children: React.ReactNode }): React.JSX.Element {\n  const commandRef = React.useRef<HTMLDivElement | null>(null)\n  const listRef = React.useRef<HTMLUListElement | null>(null)\n  const emptyRef = React.useRef<HTMLHeadingElement | null>(null)\n  const inputRef = React.useRef<HTMLInputElement | null>(null)\n\n  const [selectedItem, setSelectedItem] = React.useState<HTMLLIElement | null>(null)\n  const { itemsRef, groupsRef, filteredItemsRef } = useCommandElements(commandRef)\n\n  return (\n    <CommandRefsContext.Provider\n      value={{\n        commandRef,\n        listRef,\n        emptyRef,\n        inputRef,\n        items: itemsRef,\n        filteredItems: filteredItemsRef,\n        groups: groupsRef,\n        selectedItem,\n        setSelectedItem,\n      }}>\n      {children}\n    </CommandRefsContext.Provider>\n  )\n}\n\n/**\n * The CommandWrapper component is a wrapper for the Command component.\n * It provides a container for the command palette and handles the search functionality.\n * @function CommandWrapper\n * @param {React.HTMLProps<HTMLDivElement>} props - The properties passed to the component.\n * @returns {React.JSX.Element} The rendered CommandWrapper component.\n */\nfunction CommandWrapper({ className, ref, ...props }: React.HTMLProps<HTMLDivElement>): React.JSX.Element {\n  const [search, setSearch] = React.useState<string>('')\n  const { filteredItems, items, setSelectedItem, commandRef, groups, emptyRef, selectedItem } = useCommandRefsContext()\n\n  useCommandSearch(items, search, setSelectedItem, emptyRef, commandRef, groups, filteredItems)\n  useHandleKeyDown({\n    setSelectedItem: (item) => {\n      setSelectedItem(item)\n    },\n    itemsRef: filteredItems,\n    originalItemsRef: items,\n    allowAxisArrowKeys: false,\n    selectedItem: selectedItem,\n    open: true,\n  })\n\n  return (\n    <CommandContext.Provider\n      value={{\n        search,\n        setSearch,\n      }}>\n      <div\n        ref={commandRef}\n        duck-command-wrapper=\"\"\n        className={cn(\n          'flex h-full w-full max-w-96 flex-col overflow-hidden rounded-md bg-popover p-2 text-popover-foreground shadow-sm',\n          className,\n        )}\n        {...props}\n      />\n    </CommandContext.Provider>\n  )\n}\n\n/**\n * The Command component is a wrapper for the CommandInput and CommandList components.\n * It provides the context for the CommandInput and CommandList components.\n *\n * @param {React.ReactNode} children - The children of the Command component.\n * @returns {React.JSX.Element} The rendered Command component.\n */\nfunction Command({ children, ...props }: React.ComponentPropsWithRef<typeof CommandWrapper>): React.JSX.Element {\n  return (\n    <CommandRefs>\n      <CommandWrapper {...props}>{children}</CommandWrapper>\n    </CommandRefs>\n  )\n}\n\n/**\n * @description Component to handle the refs of the command\n * @function CommandInput\n * @param {React.HTMLAttributes<HTMLInputElement>} props - The props of the CommandInput component.\n * @returns {React.JSX.Element} The rendered CommandInput component.\n */\nfunction CommandInput({\n  className,\n  placeholder = 'Search...',\n  onChange,\n  autoFocus = true,\n  ...props\n}: React.HTMLProps<HTMLInputElement>): React.JSX.Element {\n  const { setSearch } = useCommandContext()\n  const context = useCommandRefsContext()\n\n  return (\n    <div className={cn('mb-2 flex items-center gap-2 border-b px-1', className)} cmdk-input-wrapper=\"\">\n      <Search className=\"size-[20px] shrink-0 opacity-50\" />\n      <input\n        ref={context.inputRef}\n        onChange={(e) => {\n          setSearch(() => e.target.value)\n          onChange?.(e)\n        }}\n        autoFocus={autoFocus}\n        placeholder={placeholder}\n        className={cn(\n          'flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50',\n        )}\n        tabIndex={0}\n        {...props}\n      />\n    </div>\n  )\n}\n\n/**\n * @description Component to handle the refs of the command\n * @function CommandEmpty\n * @param {React.HTMLAttributes<HTMLHeadingElement>} props - The props of the CommandEmpty component.\n * @returns {React.JSX.Element} The rendered CommandEmpty component.\n *\n */\nfunction CommandEmpty({ className, ...props }: React.HTMLAttributes<HTMLHeadingElement>): React.JSX.Element {\n  const context = useCommandRefsContext()\n  return <h6 ref={context.emptyRef} className=\"hidden py-6 text-center text-sm\" {...props} duck-command-empty=\"\" />\n}\n\n/**\n * @description Component to handle the refs of the command\n * @function CommandList\n * @param {React.HTMLAttributes<HTMLUListElement>} props - The props of the CommandList component.\n * @returns {React.JSX.Element} The rendered CommandList component.\n */\nfunction CommandList({ className, ...props }: React.HTMLAttributes<HTMLUListElement>): React.JSX.Element {\n  const context = useCommandRefsContext()\n  return (\n    <ScrollArea className=\"overflow-y-auto overflow-x-hidden\">\n      <ul ref={context.listRef} className={cn('max-h-[300px] focus:outline-none', className)} {...props} />\n    </ScrollArea>\n  )\n}\n\n/**\n * @description Component to handle the refs of the command\n * @function CommandGroup\n * @param {CommandGroupProps} props - The props of the CommandGroup component.\n * @returns {React.JSX.Element} The rendered CommandGroup component.\n */\nfunction CommandGroup({ className, children, heading, ref, ...props }: CommandGroupProps): React.JSX.Element {\n  return (\n    <div\n      ref={ref}\n      className={cn(\n        'overflow-hidden text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group-heading]]:text-xs',\n        className,\n      )}\n      {...props}\n      duck-command-group=\"\">\n      {heading && <h3 className=\"pb-1 pl-1 text-muted-foreground text-xs\">{heading}</h3>}\n      {children}\n    </div>\n  )\n}\n\n/**\n * @description Component to handle the refs of the command\n * @function CommandItem\n * @param {React.HTMLAttributes<HTMLDivElement>} props - The props of the CommandItem component.\n * @returns {React.JSX.Element} The rendered CommandItem component.\n */\nfunction CommandItem({\n  className,\n  ref,\n  value,\n  onClick,\n  onSelect,\n  onKeyDown,\n  ...props\n}: Omit<React.HTMLProps<HTMLLIElement>, 'onSelect'> & {\n  value?: string\n  onSelect?: (value: string) => void\n}): React.JSX.Element {\n  return (\n    <li\n      ref={ref}\n      duck-command-item=\"\"\n      onKeyDown={onKeyDown}\n      onClick={(e) => {\n        onSelect?.(value as string)\n        onClick?.(e)\n      }}\n      className={cn(\n        \"data-[selected= data-[disabled=true]:pointer-events-none'true']:bg-accent relative flex cursor-pointer select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden transition-color duration-300 will-change-300 hover:bg-muted hover:text-accent-foreground data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&[aria-selected]]:bg-secondary [&_svg]:size-4\",\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\n/**\n * @description Component to handle the refs of the command\n * @function CommandShortcut\n * @param {CommandBadgeProps} props - The props of the CommandShortcut component.\n * @returns {React.JSX.Element} The rendered CommandShortcut component.\n */\nimport { useKeyCommands } from '@gentleduck/vim/react'\n\nfunction CommandShortcut({\n  className,\n  keys,\n  onKeysPressed,\n  variant = 'default',\n  ref,\n  ...props\n}: CommandBadgeProps): React.JSX.Element {\n  if (keys && onKeysPressed) {\n    useKeyCommands({\n      [keys]: {\n        name: keys,\n        description: keys,\n        execute: () => onKeysPressed(),\n      },\n    })\n  }\n\n  return (\n    <kbd\n      className={cn(\n        'focus:offset-2 [&_svg]:!size-3 !font-sans pointer-events-none inline-flex cursor-none select-none items-center gap-[2px] rounded-[4px] px-2 py-[.12rem] text-[.7rem] text-muted-foreground text-secondary-foreground text-xs tracking-widest transition-colors focus:outline-hidden focus:ring-2 focus:ring-ring ltr:ml-auto rtl:mr-auto',\n        variant === 'secondary' && 'bg-secondary',\n        className,\n      )}\n      ref={ref}\n      {...props}\n    />\n  )\n}\n\n/**\n * @description Component to handle the refs of the command\n * @function CommandSeparator\n * @param {React.HTMLAttributes<HTMLDivElement>} props - The props of the CommandSeparator component.\n * @returns {React.JSX.Element} The rendered CommandSeparator component.\n */\nfunction CommandSeparator({ className, ref, ...props }: React.HTMLProps<HTMLDivElement>): React.JSX.Element {\n  return (\n    <div ref={ref} className={cn('-mx-1 my-2 h-px bg-secondary', className)} {...props} duck-command-separator=\"\" />\n  )\n}\n\n/**\n * @description Component to handle the refs of the command\n * @function CommandDialog\n * @param {React.HTMLAttributes<HTMLDivElement>} props - The props of the CommandDialog component.\n * @returns {React.JSX.Element} The rendered CommandDialog component.\n */\nfunction CommandDialog({ children, ...props }: DialogProps): React.JSX.Element {\n  return (\n    <Dialog {...props}>\n      <DialogContent className=\"fixed rounded-md p-0 open:backdrop:bg-black/80 [&>div>div]:max-w-full\">\n        <Command>{children}</Command>\n      </DialogContent>\n    </Dialog>\n  )\n}\n\nexport {\n  Command,\n  CommandInput,\n  CommandList,\n  CommandGroup,\n  CommandItem,\n  CommandEmpty,\n  CommandShortcut,\n  CommandSeparator,\n  CommandDialog,\n}\n",
      "type": "registry:ui",
      "target": "components/ui/command.tsx"
    },
    {
      "path": "command/command.types.ts",
      "content": "export interface CommandGroupProps extends React.HTMLProps<HTMLDivElement> {\n  /** The title for the command group. */\n  heading?: string\n}\n\n/**\n * Type for the context used within the Command components.\n * This context provides the current search query and a function to update it.\n */\nexport type CommandContextType = {\n  /** The current search query. */\n  search: string\n  /** A function to update the search query. */\n  setSearch: React.Dispatch<React.SetStateAction<string>>\n}\n\n/**\n * Type for the context used within the Command components.\n * This context provides references to various elements within the command palette.\n */\nexport type CommandRefsContextType = {\n  /** A Reference to the list element that contains the command items */\n  commandRef: React.RefObject<HTMLDivElement | null>\n  /** A Reference to the list element that contains the rest of list items */\n  listRef: React.RefObject<HTMLUListElement | null>\n  /** A Reference to the list element that contains the command items */\n  emptyRef: React.RefObject<HTMLHeadingElement | null>\n  /** A Reference to the input field for searching through the command items */\n  inputRef: React.RefObject<HTMLInputElement | null>\n  /** A reference to the currently selected command item. */\n  selectedItem: HTMLLIElement | null\n  /** A function to update the currently selected command item. */\n  setSelectedItem: React.Dispatch<React.SetStateAction<HTMLLIElement | null>>\n  /** A function to update the currently selected command item. */\n  items: React.RefObject<HTMLLIElement[]>\n  /** A function to update the currently selected command item. */\n  groups: React.RefObject<HTMLDivElement[]>\n  /** A function to update the currently selected command item. */\n  filteredItems: React.RefObject<HTMLLIElement[]>\n}\n\n/**\n * Props for the CommandBadge component (also used as CommandShortcut).\n * This component displays a badge that indicates the keyboard shortcut for a command.\n */\nexport interface CommandBadgeProps extends React.HTMLProps<HTMLElement> {\n  variant?: 'default' | 'secondary'\n  /** The keyboard shortcut keys (e.g., \"ctrl+K\"). */\n  keys?: string\n  /** Callback function that is invoked when the shortcut keys are pressed. */\n  onKeysPressed?: () => void\n}\n",
      "type": "registry:ui",
      "target": "components/ui/command.types.ts"
    },
    {
      "path": "command/index.ts",
      "content": "export * from './command'\nexport * from './command.hooks'\nexport * from './command.libs'\nexport * from './command.types'\n",
      "type": "registry:ui",
      "target": "components/ui/index.ts"
    }
  ],
  "source": "/registry-ui-duckui/src/command"
}