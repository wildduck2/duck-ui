import { readdir, writeFile } from 'node:fs/promises'
import path from 'node:path'

type EmojiEntry = {
  name: string // like "slight_smile"
  file: string // relative path like "emoji/kissing_smiling_eyes.svg"
  group?: string // optional folder group (like "smileys")
}

const DEFAULT_EXTS = new Set(['.svg'])

function slugToShortcodeName(fileBase: string) {
  // "astonished-1" -> "astonished_1"
  // "face with monocle" -> "face_with_monocle"
  return fileBase
    .trim()
    .toLowerCase()
    .replace(/\s+/g, '_')
    .replace(/-+/g, '_')
    .replace(/[^a-z0-9_]/g, '_')
    .replace(/_+/g, '_')
    .replace(/^_+|_+$/g, '')
}

async function walk(dirAbs: string): Promise<string[]> {
  const out: string[] = []
  const items = await readdir(dirAbs, { withFileTypes: true })

  for (const it of items) {
    const abs = path.join(dirAbs, it.name)
    if (it.isDirectory()) {
      out.push(...(await walk(abs)))
    } else if (it.isFile()) {
      out.push(abs)
    } else {
      // ignore symlinks, etc
    }
  }
  return out
}

function posixRel(fromAbs: string, toAbs: string) {
  const rel = path.relative(fromAbs, toAbs)
  return rel.split(path.sep).join(path.posix.sep)
}

function guessGroup(rootRelFile: string) {
  // If your structure is "emoji/<group>/<file>.svg", group is the first folder after emoji/
  // If your structure is just "emoji/<file>.svg", group stays undefined
  const parts = rootRelFile.split('/')
  // example: ["emoji","smileys","grin.svg"]
  if (parts.length >= 3) return parts[1]
  return undefined
}

async function main() {
  // Usage:
  //   ts-node scripts/generate-emoji-index.ts ./public/emoji ./src/generated
  // Defaults:
  //   rootDir = "./public/emoji"
  //   outDir  = "./src/generated"
  const rootDir = path.resolve(process.argv[2] ?? './public/emoji')
  const outDir = path.resolve(process.argv[3] ?? './src/generated')

  const rootParent = path.dirname(rootDir) // so output file paths can include "emoji/..."
  const allAbs = await walk(rootDir)

  const svgAbs = []
  for (const f of allAbs) {
    const ext = path.extname(f).toLowerCase()
    if (DEFAULT_EXTS.has(ext)) svgAbs.push(f)
  }

  // Stable ordering helps diffing and caching
  svgAbs.sort((a, b) => a.localeCompare(b))

  const usedNames = new Map<string, number>() // baseName -> count
  const entries: EmojiEntry[] = []

  for (const abs of svgAbs) {
    const relFromParent = posixRel(rootParent, abs) // "emoji/grin.svg" or "emoji/smileys/grin.svg"
    const base = path.basename(abs, path.extname(abs)) // "astonished-1"
    const baseName = slugToShortcodeName(base)

    if (!baseName) continue

    const n = (usedNames.get(baseName) ?? 0) + 1
    usedNames.set(baseName, n)

    const name = n === 1 ? baseName : `${baseName}_${n}`

    entries.push({
      name,
      file: relFromParent,
      group: guessGroup(relFromParent),
    })
  }

  // Build a map for instant lookup during message rendering
  const map: Record<string, string> = {}
  for (const e of entries) {
    // key is without colons too, but you can choose what you prefer
    map[e.name] = e.file // "slight_smile" -> "emoji/slight_smile.svg"
  }

  // Write JSON (good for runtime fetch)
  const jsonPath = path.join(outDir, 'emoji-index.json')
  const tsPath = path.join(outDir, 'emoji-index.ts')

  await writeFile(jsonPath, JSON.stringify({ entries, map }, null, 2), 'utf8')

  // Write TS module (good for bundlers and typing)
  const ts = `// AUTO-GENERATED by generate-emoji-index.ts. DO NOT EDIT.
export type EmojiEntry = ${JSON.stringify({} as EmojiEntry, null, 2)
    .replace(/"shortcode": ""/g, 'shortcode: string')
    .replace(/"name": ""/g, 'name: string')
    .replace(/"file": ""/g, 'file: string')
    .replace(/"group": ""/g, 'group?: string')};

export const emojiEntries = ${JSON.stringify(entries, null, 2)} as const;

export const emojiMap: Record<string, string> = ${JSON.stringify(map, null, 2)};

// Helper: replace :shortcode: in text with a renderer callback
export function replaceShortcodes(
  text: string,
  render: (name: string, file: string) => string
): string {
  // Accept letters, numbers, underscore. Example: :slight_smile:
  return text.replace(/:([a-z0-9_]+):/gi, (full, raw) => {
    const name = String(raw).toLowerCase();
    const file = emojiMap[name];
    if (!file) return full;
    return render(name, file);
  });
}
`
  await writeFile(tsPath, ts, 'utf8')

  console.log(`Found ${entries.length} emoji`)
  console.log(`Wrote:\n  ${jsonPath}\n  ${tsPath}`)
}

main().catch((err) => {
  console.error(err)
  process.exit(1)
})
